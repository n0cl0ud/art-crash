<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibe Collector - Action Economy Puzzler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e, #16213e);
            font-family: 'Press Start 2P', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 4px solid #fff;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            background: #000;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #fff;
            font-size: 8px;
            z-index: 100;
            text-shadow: 2px 2px 0px #000;
        }
        
        .level-info {
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #fff;
            border-radius: 4px;
            backdrop-filter: blur(5px);
        }
        
        .action-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        
        .action-counter {
            padding: 6px 8px;
            border: 2px solid;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .action-counter.depleted {
            opacity: 0.4;
            filter: grayscale(0.8);
        }
        
        .action-counter::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .pulsing {
            animation: pulse 0.6s ease-in-out;
        }
        
        .jump-counter { 
            background: linear-gradient(135deg, #444, #666);
            border-color: #fff;
            color: #fff;
        }
        
        .dash-counter { 
            background: linear-gradient(135deg, #ff00ff, #ff44ff);
            border-color: #ff88ff;
            color: #fff;
        }
        
        .teleport-counter { 
            background: linear-gradient(135deg, #00ff00, #44ff44);
            border-color: #88ff88;
            color: #000;
        }
        
        .wallbounce-counter { 
            background: linear-gradient(135deg, #00ffff, #44ffff);
            border-color: #88ffff;
            color: #000;
        }
        
        .stats {
            margin-top: 12px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
            border-radius: 4px;
            font-size: 7px;
        }
        
        .death-counter {
            color: #ff4444;
        }
        
        .level-progress {
            color: #44ff44;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #aaa;
            font-size: 6px;
            text-shadow: 1px 1px 0px #000;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .speed-control {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #fff;
            font-size: 6px;
            text-shadow: 1px 1px 0px #000;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border: 2px solid #444;
            border-radius: 4px;
        }
        
        .speed-slider {
            width: 80px;
            margin-top: 4px;
            accent-color: #ff00ff;
        }
        
        .speed-value {
            color: #ff00ff;
            font-weight: bold;
        }
        
        .level-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffff00;
            padding: 20px;
            border: 4px solid #ffff00;
            border-radius: 8px;
            text-align: center;
            animation: bounce 0.5s ease-out;
            z-index: 200;
        }
        
        @keyframes bounce {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div class="level-info">
                <div>LEVEL <span id="currentLevel">1</span>/10</div>
                <div id="levelName">TUTORIAL: JUMP</div>
            </div>
            
            <div class="action-grid">
                <div class="action-counter jump-counter">
                    <div>JUMP</div>
                    <div id="jumpCount">3</div>
                </div>
                <div class="action-counter dash-counter">
                    <div>DASH</div>
                    <div id="dashCount">0</div>
                </div>
                <div class="action-counter teleport-counter">
                    <div>WARP</div>
                    <div id="teleportCount">0</div>
                </div>
                <div class="action-counter wallbounce-counter">
                    <div>BOUNCE</div>
                    <div id="wallbounceCount">0</div>
                </div>
            </div>
            
            <div class="stats">
                <div class="death-counter">DEATHS: <span id="deathCount">0</span></div>
                <div class="level-progress">BEST: <span id="bestMoves">--</span> MOVES</div>
            </div>
        </div>
        
        <div class="controls-hint">
            WASD=MOVE • SPACE=JUMP • SHIFT=DASH • COMBOS: SHIFT→SPACE • E=WARP • R=RESET
        </div>
        
        <div class="speed-control">
            <div>GAME SPEED</div>
            <input type="range" class="speed-slider" id="speedSlider" min="0.3" max="2.0" step="0.1" value="1.0">
            <div>x<span class="speed-value" id="speedValue">1.0</span></div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <script>
        console.log("🎮 Vibe Collector - Action Economy Puzzler");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Game state
        let player = {
            x: 100, y: 500, size: 16, vx: 0, vy: 0,
            startX: 100, startY: 500,
            grounded: false, onWall: false, wallSide: null,
            state: 'normal', animFrame: 0, facing: 1
        };
        
        let actions = { jumps: 3, dashes: 0, teleports: 0, wallbounces: 0 };
        let startingActions = { jumps: 3, dashes: 0, teleports: 0, wallbounces: 0 };
        let currentLevel = 1;
        let deathCount = 0;
        let particles = [];
        let keys = {};
        let time = 0;
        let totalMoves = 0;
        let levelStats = {}; // Store best completion for each level
        let gameSpeed = 1.0; // Global speed multiplier
        let lastJumpTime = 0; // Simple jump spam protection
        let goalEffect = { active: false, time: 0, particles: [], vortexParticles: [] }; // Epic goal effects
        let lastDashTime = 0; // For coyote time jumping after dash
        
        // Easier level progression for better learning curve
        const levels = {
            1: {
                name: "FIRST STEPS",
                description: "Learn to jump",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 500, width: 40, height: 40 },
                startingActions: { jumps: 5, dashes: 0, teleports: 0, wallbounces: 0 },
                optimalMoves: 2,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 300, y: 500, width: 200, height: 20 },
                    { x: 600, y: 540, width: 150, height: 20 }
                ],
                hazards: [],
                vibes: [
                    { x: 400, y: 470, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [], trees: [], walls: [], bgColor: '#1a1a2e'
            },
            
            2: {
                name: "SIMPLE HOPS",
                description: "Master basic jumping",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 400, width: 40, height: 40 },
                startingActions: { jumps: 4, dashes: 0, teleports: 0, wallbounces: 0 },
                optimalMoves: 3,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 300, y: 500, width: 100, height: 20 },
                    { x: 500, y: 450, width: 100, height: 20 },
                    { x: 600, y: 440, width: 150, height: 20 }
                ],
                hazards: [],
                vibes: [
                    { x: 350, y: 470, type: 'jump', collected: false, size: 12, pulse: 0 },
                    { x: 550, y: 420, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [], trees: [], walls: [], bgColor: '#1a1a2e'
            },
            
            3: {
                name: "DASH + JUMP COMBO",
                description: "Dash then jump to reach far platforms",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 300, width: 40, height: 40 },
                startingActions: { jumps: 3, dashes: 1, teleports: 0, wallbounces: 0 },
                optimalMoves: 3,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 300, y: 450, width: 100, height: 20 },
                    { x: 600, y: 340, width: 150, height: 20 }
                ],
                hazards: [],
                vibes: [
                    { x: 525, y: 310, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [
                    // Grid positioned to require dash+jump combo
                    { type: 'horizontal', y: 400, start: 200, end: 500 }
                ],
                trees: [], walls: [], bgColor: '#2e1a1a'
            },
            
            4: {
                name: "EASY FIRE",
                description: "Dash through small flames",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 300, width: 40, height: 40 },
                startingActions: { jumps: 2, dashes: 1, teleports: 0, wallbounces: 0 },
                optimalMoves: 3,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 300, y: 450, width: 100, height: 20 },
                    { x: 600, y: 340, width: 150, height: 20 }
                ],
                hazards: [
                    { x: 350, y: 400, width: 200, height: 50, type: 'fire' }
                ],
                vibes: [
                    // FIXED: Moved vibe away from fire danger
                    { x: 250, y: 420, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [
                    { type: 'horizontal', y: 375, start: 400, end: 600 }
                ],
                trees: [], walls: [], bgColor: '#2e1a1a'
            },
            
            5: {
                name: "TELEPORT INTRO",
                description: "Warp between trees",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 200, width: 40, height: 40 },
                startingActions: { jumps: 2, dashes: 0, teleports: 0, wallbounces: 0 },
                optimalMoves: 3,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 200, y: 450, width: 100, height: 20 },
                    { x: 600, y: 240, width: 150, height: 20 }
                ],
                hazards: [
                    { x: 320, y: 350, width: 250, height: 100, type: 'electric' }
                ],
                vibes: [
                    { x: 250, y: 420, type: 'teleport', collected: false, size: 12, pulse: 0 },
                    { x: 675, y: 210, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [],
                trees: [
                    { x: 250, y: 450, size: 25 },
                    { x: 450, y: 250, size: 25 },
                    { x: 675, y: 240, size: 25 }
                ],
                walls: [], bgColor: '#1a2e1a'
            },
            
            6: {
                name: "WALL BOUNCE BASIC",
                description: "Bounce off walls through ice",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 200, width: 40, height: 40 },
                startingActions: { jumps: 2, dashes: 0, teleports: 0, wallbounces: 0 },
                optimalMoves: 4,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 600, y: 240, width: 150, height: 20 }
                ],
                hazards: [
                    { x: 250, y: 450, width: 300, height: 60, type: 'ice' }
                ],
                vibes: [
                    // FIXED: Moved vibes away from ice danger - much safer positions
                    { x: 200, y: 400, type: 'wallbounce', collected: false, size: 12, pulse: 0 },
                    { x: 400, y: 350, type: 'wallbounce', collected: false, size: 12, pulse: 0 },
                    { x: 675, y: 210, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [],
                trees: [],
                walls: [
                    { x: 300, y: 300, width: 20, height: 150 },
                    { x: 460, y: 250, width: 20, height: 200 }
                ],
                bgColor: '#1a2e2e'
            },
            
            7: {
                name: "COMBINATION TIME",
                description: "Use multiple abilities",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 150, width: 40, height: 40 },
                startingActions: { jumps: 1, dashes: 0, teleports: 0, wallbounces: 0 },
                optimalMoves: 5,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 250, y: 450, width: 80, height: 20 },
                    { x: 450, y: 350, width: 80, height: 20 },
                    { x: 600, y: 190, width: 150, height: 20 }
                ],
                hazards: [
                    { x: 200, y: 400, width: 100, height: 80, type: 'fire' },
                    { x: 380, y: 300, width: 150, height: 80, type: 'electric' }
                ],
                vibes: [
                    { x: 200, y: 370, type: 'dash', collected: false, size: 12, pulse: 0 },
                    { x: 490, y: 320, type: 'teleport', collected: false, size: 12, pulse: 0 },
                    { x: 675, y: 160, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [
                    { type: 'horizontal', y: 370, start: 200, end: 300 }
                ],
                trees: [
                    { x: 300, y: 350, size: 25 },
                    { x: 490, y: 250, size: 25 },
                    { x: 675, y: 190, size: 25 }
                ],
                walls: [], bgColor: '#2e1a2e'
            },
            
            8: {
                name: "PLANNING CHALLENGE",
                description: "Think before you move",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 100, width: 40, height: 40 },
                startingActions: { jumps: 1, dashes: 0, teleports: 0, wallbounces: 0 },
                optimalMoves: 6,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 250, y: 450, width: 80, height: 20 },
                    { x: 400, y: 350, width: 80, height: 20 },
                    { x: 550, y: 250, width: 80, height: 20 },
                    { x: 600, y: 140, width: 150, height: 20 }
                ],
                hazards: [
                    { x: 180, y: 400, width: 150, height: 80, type: 'fire' },
                    { x: 330, y: 300, width: 150, height: 80, type: 'electric' },
                    { x: 480, y: 200, width: 150, height: 80, type: 'ice' }
                ],
                vibes: [
                    { x: 290, y: 420, type: 'dash', collected: false, size: 12, pulse: 0 },
                    { x: 440, y: 320, type: 'teleport', collected: false, size: 12, pulse: 0 },
                    { x: 590, y: 220, type: 'wallbounce', collected: false, size: 12, pulse: 0 },
                    { x: 675, y: 110, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [
                    { type: 'horizontal', y: 400, start: 180, end: 330 },
                    { type: 'horizontal', y: 220, start: 480, end: 630 }
                ],
                trees: [
                    { x: 370, y: 280, size: 25 },
                    { x: 440, y: 220, size: 25 },
                    { x: 675, y: 140, size: 25 }
                ],
                walls: [
                    { x: 520, y: 180, width: 20, height: 70 }
                ],
                bgColor: '#1a1a2e'
            },
            
            9: {
                name: "ADVANCED TACTICS",
                description: "Master all techniques",
                spawn: { x: 100, y: 500 },
                goal: { x: 650, y: 50, width: 40, height: 40 },
                startingActions: { jumps: 0, dashes: 1, teleports: 0, wallbounces: 0 },
                optimalMoves: 7,
                platforms: [
                    { x: 50, y: 550, width: 150, height: 20 },
                    { x: 600, y: 90, width: 150, height: 20 }
                ],
                hazards: [
                    { x: 220, y: 480, width: 100, height: 70, type: 'fire' },
                    { x: 350, y: 380, width: 120, height: 70, type: 'electric' },
                    { x: 480, y: 280, width: 120, height: 70, type: 'ice' },
                    { x: 350, y: 150, width: 200, height: 60, type: 'deadly' }
                ],
                vibes: [
                    { x: 270, y: 430, type: 'jump', collected: false, size: 12, pulse: 0 },
                    { x: 410, y: 330, type: 'teleport', collected: false, size: 12, pulse: 0 },
                    { x: 540, y: 230, type: 'wallbounce', collected: false, size: 12, pulse: 0 },
                    { x: 320, y: 100, type: 'dash', collected: false, size: 12, pulse: 0 },
                    { x: 675, y: 60, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [
                    { type: 'horizontal', y: 450, start: 200, end: 320 },
                    { type: 'horizontal', y: 350, start: 320, end: 470 },
                    { type: 'horizontal', y: 250, start: 450, end: 600 },
                    { type: 'horizontal', y: 100, start: 300, end: 350 }
                ],
                trees: [
                    { x: 300, y: 380, size: 25 },
                    { x: 410, y: 280, size: 25 },
                    { x: 320, y: 100, size: 25 },
                    { x: 675, y: 90, size: 25 }
                ],
                walls: [
                    { x: 320, y: 100, width: 20, height: 50 },
                    { x: 540, y: 200, width: 20, height: 80 }
                ],
                bgColor: '#2e1a1a'
            },
            
            10: {
                name: "MASTER ECONOMIST",
                description: "The ultimate test",
                spawn: { x: 100, y: 500 },
                goal: { x: 700, y: 50, width: 40, height: 40 },
                startingActions: { jumps: 0, dashes: 0, teleports: 0, wallbounces: 0 },
                optimalMoves: 10,
                platforms: [
                    { x: 50, y: 550, width: 100, height: 20 },
                    { x: 200, y: 450, width: 60, height: 20 },
                    { x: 340, y: 350, width: 60, height: 20 },
                    { x: 480, y: 250, width: 60, height: 20 },
                    { x: 620, y: 150, width: 60, height: 20 },
                    { x: 650, y: 90, width: 100, height: 80 }
                ],
                hazards: [
                    { x: 150, y: 400, width: 110, height: 100, type: 'fire' },
                    { x: 280, y: 300, width: 120, height: 100, type: 'electric' },
                    { x: 420, y: 200, width: 120, height: 100, type: 'ice' },
                    { x: 560, y: 100, width: 120, height: 100, type: 'deadly' },
                    { x: 300, y: 100, width: 80, height: 50, type: 'fire' }
                ],
                vibes: [
                    { x: 150, y: 350, type: 'jump', collected: false, size: 12, pulse: 0 },
                    { x: 230, y: 420, type: 'dash', collected: false, size: 12, pulse: 0 },
                    { x: 370, y: 320, type: 'teleport', collected: false, size: 12, pulse: 0 },
                    { x: 510, y: 220, type: 'wallbounce', collected: false, size: 12, pulse: 0 },
                    { x: 340, y: 75, type: 'dash', collected: false, size: 12, pulse: 0 },
                    { x: 480, y: 150, type: 'jump', collected: false, size: 12, pulse: 0 },
                    { x: 650, y: 120, type: 'teleport', collected: false, size: 12, pulse: 0 },
                    { x: 700, y: 60, type: 'jump', collected: false, size: 12, pulse: 0 }
                ],
                grids: [
                    { type: 'horizontal', y: 350, start: 150, end: 260 },
                    { type: 'horizontal', y: 250, start: 280, end: 400 },
                    { type: 'horizontal', y: 150, start: 420, end: 540 },
                    { type: 'horizontal', y: 75, start: 300, end: 380 },
                    { type: 'vertical', x: 340, start: 75, end: 150 }
                ],
                trees: [
                    { x: 200, y: 350, size: 25 },
                    { x: 370, y: 250, size: 25 },
                    { x: 340, y: 75, size: 25 },
                    { x: 650, y: 120, size: 25 },
                    { x: 700, y: 90, size: 25 }
                ],
                walls: [
                    { x: 340, y: 150, width: 20, height: 100 },
                    { x: 510, y: 150, width: 20, height: 100 }
                ],
                bgColor: '#2e2e2e'
            }
        };
        
        // Input handling - Fixed multi-key conflicts
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            // Instant actions (no cooldown conflicts)
            if (key === 'r') {
                resetLevel();
                return;
            }
            
            if (key === 'e') {
                tryTreeTeleport();
                return;
            }
            
            // Jump/Wall Bounce - simplified, no cooldown interference
            if (e.key === ' ') {
                e.preventDefault();
                // Direct check, no cooldown to interfere with movement
                if (player.onWall) {
                    tryWallBounce();
                } else if (player.grounded) {
                    tryJump();
                }
                return;
            }
            
            // Dash handling - only when shift is actively pressed
            if (key === 'shift') {
                tryGridDash();
                return;
            }
            
            // Debug controls
            if (key === 'n' && currentLevel < 10) {
                currentLevel++;
                loadLevel(currentLevel);
            }
            if (key === 'p' && currentLevel > 1) {
                currentLevel--;
                loadLevel(currentLevel);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        function flashUI(className) {
            const element = document.querySelector('.' + className);
            if (element) {
                element.classList.add('pulsing');
                setTimeout(() => element.classList.remove('pulsing'), 600);
            }
        }
        
        function tryJump() {
            // Simple spam protection - 100ms between jumps
            const now = Date.now();
            if (now - lastJumpTime < 100) return;
            
            if (actions.jumps <= 0) return;
            
            // ENHANCED: Allow jumping if grounded OR recently dashed (coyote time)
            const recentlyDashed = (now - lastDashTime) < 200; // 200ms grace period after dash
            
            if (!player.grounded && !recentlyDashed) return;
            
            lastJumpTime = now;
            actions.jumps--;
            totalMoves++;
            // FIXED: Jump force should NOT be affected by speed (prevents cheating)
            player.vy = -12; // Constant jump force regardless of speed
            player.grounded = false;
            
            // CRITICAL FIX: Allow jumping during dash! End dash state when jumping
            if (player.state === 'dashing') {
                player.state = 'normal';
                console.log("🚀 Jump during dash - combo move!");
            }
            
            if (recentlyDashed && !player.grounded) {
                console.log("🦘 Coyote jump after dash!");
            }
            
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: player.x + player.size/2, 
                    y: player.y + player.size,
                    vx: (Math.random() - 0.5) * 6 * gameSpeed,
                    vy: Math.random() * 3 + 1,
                    life: 30, 
                    color: '#ffffff',
                    size: Math.random() * 3 + 1
                });
            }
            
            flashUI('jump-counter');
            updateUI();
        }
        
        function tryGridDash() {
            if (actions.dashes <= 0) return;
            
            const level = getCurrentLevel();
            let dashDirection = null;
            let closestGrid = null;
            let closestDistance = Infinity;
            
            // MUCH SIMPLER: Just dash in the direction you're moving or facing
            level.grids.forEach(grid => {
                let distance = Infinity;
                let direction = null;
                
                if (grid.type === 'horizontal') {
                    distance = Math.abs(player.y - grid.y);
                    // Much more forgiving range - 80 pixels!
                    if (distance < 80 && 
                        player.x >= grid.start - 80 && 
                        player.x <= grid.end + 80) {
                        
                        // SIMPLIFIED: Dash in direction you're facing, or use current movement
                        if (player.facing > 0 || keys['d'] || keys['arrowright']) {
                            direction = { x: 1, y: 0, line: grid };
                        } else if (player.facing < 0 || keys['a'] || keys['arrowleft']) {
                            direction = { x: -1, y: 0, line: grid };
                        } else {
                            // Default to right if no direction
                            direction = { x: 1, y: 0, line: grid };
                        }
                    }
                } else if (grid.type === 'vertical') {
                    distance = Math.abs(player.x - grid.x);
                    // Much more forgiving range
                    if (distance < 80 && 
                        player.y >= grid.start - 80 && 
                        player.y <= grid.end + 80) {
                        
                        // For vertical grids, prefer upward dash
                        if (keys['w'] || keys['arrowup']) {
                            direction = { x: 0, y: -1, line: grid };
                        } else if (keys['s'] || keys['arrowdown']) {
                            direction = { x: 0, y: 1, line: grid };
                        } else {
                            // Default to up
                            direction = { x: 0, y: -1, line: grid };
                        }
                    }
                }
                
                // Choose the closest grid if multiple are available
                if (direction && distance < closestDistance) {
                    closestDistance = distance;
                    dashDirection = direction;
                    closestGrid = grid;
                }
            });
            
            if (dashDirection) {
                actions.dashes--;
                totalMoves++;
                
                // Track dash time for coyote jumping
                lastDashTime = Date.now();
                
                // Auto-snap to grid line (very forgiving)
                if (dashDirection.line.type === 'horizontal') {
                    player.y = dashDirection.line.y;
                    // CRITICAL FIX: Make player grounded on horizontal grids!
                    player.grounded = true;
                    player.vy = 0; // Stop falling
                } else {
                    player.x = dashDirection.line.x;
                }
                
                // Constant dash speed
                player.vx = dashDirection.x * 15;
                player.vy = dashDirection.y * 15;
                player.state = 'dashing';
                
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: player.x, y: player.y,
                        vx: -dashDirection.x * 8 + (Math.random() - 0.5) * 4,
                        vy: -dashDirection.y * 8 + (Math.random() - 0.5) * 4,
                        life: 25, 
                        color: '#ff00ff',
                        size: Math.random() * 4 + 2
                    });
                }
                
                setTimeout(() => { 
                    if (player.state === 'dashing') {
                        player.state = 'normal'; 
                    }
                }, 100); // FIXED: Much shorter dash duration - 100ms instead of 200ms
                flashUI('dash-counter');
                updateUI();
                
                console.log(`💫 Auto-dashed ${dashDirection.x > 0 ? 'right' : dashDirection.x < 0 ? 'left' : dashDirection.y > 0 ? 'down' : 'up'}!`);
            } else {
                // Better feedback
                console.log("❌ No dash grid in range! Look for BRIGHT YELLOW pulsing lines!");
                
                // Visual feedback - flash all grids briefly
                level.grids.forEach(grid => {
                    // Add a brief flash effect to help player locate grids
                    particles.push({
                        x: grid.type === 'horizontal' ? (grid.start + grid.end)/2 : grid.x,
                        y: grid.type === 'horizontal' ? grid.y : (grid.start + grid.end)/2,
                        vx: 0, vy: 0,
                        life: 30,
                        color: '#ff00ff',
                        size: 8
                    });
                });
            }
        }
        
        function tryTreeTeleport() {
            if (actions.teleports <= 0) return;
            
            const level = getCurrentLevel();
            // IMPROVED: More forgiving teleport range
            const nearTree = level.trees.find(tree => {
                const dx = player.x + player.size/2 - tree.x;
                const dy = player.y + player.size/2 - tree.y;
                return Math.sqrt(dx * dx + dy * dy) < tree.size + 40; // Increased range
            });
            
            if (nearTree) {
                const otherTrees = level.trees.filter(t => t !== nearTree);
                if (otherTrees.length > 0) {
                    actions.teleports--;
                    totalMoves++;
                    
                    const target = otherTrees[Math.floor(Math.random() * otherTrees.length)];
                    player.x = target.x - player.size/2;
                    player.y = target.y - player.size;
                    player.vx = 0;
                    player.vy = 0;
                    player.state = 'just_teleported';
                    
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: player.x, y: player.y,
                            vx: (Math.random() - 0.5) * 10 * gameSpeed,
                            vy: (Math.random() - 0.5) * 10 * gameSpeed,
                            life: 40, 
                            color: '#00ff00',
                            size: Math.random() * 5 + 2
                        });
                    }
                    
                    setTimeout(() => { 
                        if (player.state === 'just_teleported') {
                            player.state = 'normal'; 
                        }
                    }, 300 / gameSpeed);
                    
                    flashUI('teleport-counter');
                    updateUI();
                    
                    console.log("⚡ Teleported between trees!");
                } else {
                    console.log("❌ No other trees to teleport to!");
                }
            } else {
                console.log("❌ Not close enough to a tree! Get within the green glow.");
            }
        }
        
        function tryWallBounce() {
            if (actions.wallbounces <= 0 || !player.onWall) return;
            
            actions.wallbounces--;
            totalMoves++;
            
            // FIXED: Wall bounce force should NOT be affected by speed (prevents cheating)
            const bounceForce = 12; // Constant force regardless of speed
            if (player.wallSide === 'left') {
                player.vx = bounceForce;
                player.facing = 1;
            } else if (player.wallSide === 'right') {
                player.vx = -bounceForce;
                player.facing = -1;
            }
            player.vy = -bounceForce;
            player.state = 'just_bounced';
            
            for (let i = 0; i < 12; i++) {
                particles.push({
                    x: player.x, y: player.y,
                    vx: (Math.random() - 0.5) * 8 * gameSpeed,
                    vy: (Math.random() - 0.5) * 8 * gameSpeed,
                    life: 30, 
                    color: '#00ffff',
                    size: Math.random() * 4 + 1
                });
            }
            
            setTimeout(() => { 
                if (player.state === 'just_bounced') {
                    player.state = 'normal'; 
                }
            }, 300 / gameSpeed);
            
            flashUI('wallbounce-counter');
            updateUI();
        }
        
        function collectVibe(vibe) {
            vibe.collected = true;
            
            switch(vibe.type) {
                case 'jump':
                    actions.jumps++;
                    flashUI('jump-counter');
                    break;
                case 'dash':
                    actions.dashes++;
                    flashUI('dash-counter');
                    break;
                case 'teleport':
                    actions.teleports++;
                    flashUI('teleport-counter');
                    break;
                case 'wallbounce':
                    actions.wallbounces++;
                    flashUI('wallbounce-counter');
                    break;
            }
            
            const colors = {
                jump: '#ffffff',
                dash: '#ff00ff', 
                teleport: '#00ff00',
                wallbounce: '#00ffff'
            };
            
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: vibe.x, y: vibe.y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 50, 
                    color: colors[vibe.type],
                    size: Math.random() * 6 + 2
                });
            }
            
            updateUI();
        }
        
        function getCurrentLevel() {
            return levels[currentLevel] || levels[1];
        }
        
        function loadLevel(levelNum) {
            const level = levels[levelNum];
            if (!level) return;
            
            player.x = level.spawn.x;
            player.y = level.spawn.y;
            player.startX = level.spawn.x;
            player.startY = level.spawn.y;
            player.vx = 0;
            player.vy = 0;
            player.state = 'normal';
            player.facing = 1;
            
            actions = { ...level.startingActions };
            startingActions = { ...level.startingActions };
            totalMoves = 0;
            
            level.vibes.forEach(vibe => vibe.collected = false);
            
            particles = [];
            updateUI();
        }
        
        function resetLevel() {
            deathCount++;
            loadLevel(currentLevel);
            
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: player.x, y: player.y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 50, 
                    color: '#ff0000',
                    size: Math.random() * 8 + 3
                });
            }
        }
        
        function nextLevel() {
            // Record best performance
            const levelKey = `level_${currentLevel}`;
            if (!levelStats[levelKey] || totalMoves < levelStats[levelKey]) {
                levelStats[levelKey] = totalMoves;
            }
            
            // Reset vortex effect
            goalEffect.active = false;
            goalEffect.vortexParticles = [];
            
            if (levels[currentLevel + 1]) {
                currentLevel++;
                loadLevel(currentLevel);
                
                // Success celebration particles
                for (let i = 0; i < 30; i++) {
                    particles.push({
                        x: player.x, y: player.y,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20,
                        life: 60, 
                        color: ['#ffff00', '#ff00ff', '#00ffff', '#00ff00'][Math.floor(Math.random() * 4)],
                        size: Math.random() * 8 + 4
                    });
                }
                
                console.log(`🎯 Level ${currentLevel-1} completed! Moving to: ${getCurrentLevel().name}`);
            } else {
                showGameComplete();
            }
        }
        
        function showGameComplete() {
            const completeDiv = document.createElement('div');
            completeDiv.className = 'level-complete';
            completeDiv.innerHTML = `
                <div>🎉 GAME COMPLETE! 🎉</div>
                <div style="margin-top: 10px; font-size: 6px;">
                    MASTER ECONOMIST ACHIEVED!<br>
                    TOTAL DEATHS: ${deathCount}<br>
                    Press R to play again
                </div>
            `;
            document.getElementById('gameContainer').appendChild(completeDiv);
            
            setTimeout(() => completeDiv.remove(), 5000);
        }
        
        function updateUI() {
            document.getElementById('currentLevel').textContent = currentLevel;
            document.getElementById('levelName').textContent = getCurrentLevel().name;
            document.getElementById('jumpCount').textContent = actions.jumps;
            document.getElementById('dashCount').textContent = actions.dashes;
            document.getElementById('teleportCount').textContent = actions.teleports;
            document.getElementById('wallbounceCount').textContent = actions.wallbounces;
            document.getElementById('deathCount').textContent = deathCount;
            
            // Update best moves display
            const levelKey = `level_${currentLevel}`;
            const bestMoves = levelStats[levelKey] || getCurrentLevel().optimalMoves;
            document.getElementById('bestMoves').textContent = bestMoves;
            
            // Update action counter styles based on availability
            document.querySelector('.jump-counter').classList.toggle('depleted', actions.jumps === 0);
            document.querySelector('.dash-counter').classList.toggle('depleted', actions.dashes === 0);
            document.querySelector('.teleport-counter').classList.toggle('depleted', actions.teleports === 0);
            document.querySelector('.wallbounce-counter').classList.toggle('depleted', actions.wallbounces === 0);
        }
        
        function updatePlayer() {
            const level = getCurrentLevel();
            const gravity = 0.5 * gameSpeed;
            const friction = 0.8;
            const moveSpeed = 4 * gameSpeed;
            const jumpForce = 12 * gameSpeed;
            
            // Reset states before collision detection
            player.grounded = false;
            player.onWall = false;
            player.wallSide = null;
            
            // Platform collision - improved grounded detection
            level.platforms.forEach(platform => {
                // Ground collision - more forgiving detection
                if (player.x + player.size > platform.x && 
                    player.x < platform.x + platform.width &&
                    player.y + player.size >= platform.y && 
                    player.y + player.size <= platform.y + platform.height + 12 &&
                    player.vy >= -1) { // Allow slight upward velocity to still be grounded
                    player.y = platform.y - player.size;
                    player.vy = 0;
                    player.grounded = true;
                }
                
                // Wall collision
                if (player.y + player.size > platform.y && 
                    player.y < platform.y + platform.height) {
                    if (player.x + player.size > platform.x && 
                        player.x + player.size < platform.x + 10 &&
                        player.vx > 0) {
                        player.x = platform.x - player.size;
                        player.vx = 0;
                        player.onWall = true;
                        player.wallSide = 'left';
                    }
                    if (player.x < platform.x + platform.width && 
                        player.x > platform.x + platform.width - 10 &&
                        player.vx < 0) {
                        player.x = platform.x + platform.width;
                        player.vx = 0;
                        player.onWall = true;
                        player.wallSide = 'right';
                    }
                }
            });
            
            // ADDED: Grid collision - treat horizontal grids as invisible platforms
            level.grids.forEach(grid => {
                if (grid.type === 'horizontal') {
                    // Create invisible platform on the grid line
                    if (player.x + player.size > grid.start && 
                        player.x < grid.end &&
                        player.y + player.size >= grid.y && 
                        player.y + player.size <= grid.y + 12 &&
                        player.vy >= -1) {
                        player.y = grid.y - player.size;
                        player.vy = 0;
                        player.grounded = true;
                    }
                }
            });
            
            // Wall objects collision
            level.walls.forEach(wall => {
                if (player.y + player.size > wall.y && 
                    player.y < wall.y + wall.height) {
                    if (player.x + player.size > wall.x && 
                        player.x + player.size < wall.x + 10 &&
                        player.vx > 0) {
                        player.x = wall.x - player.size;
                        player.vx = 0;
                        player.onWall = true;
                        player.wallSide = 'left';
                    }
                    if (player.x < wall.x + wall.width && 
                        player.x > wall.x + wall.width - 10 &&
                        player.vx < 0) {
                        player.x = wall.x + wall.width;
                        player.vx = 0;
                        player.onWall = true;
                        player.wallSide = 'right';
                    }
                }
            });
            
            // Movement - Allow some control even during dash
            if (player.state !== 'dashing') {
                // Normal movement
                let horizontalInput = 0;
                
                // Check all possible left inputs
                if (keys['a'] || keys['arrowleft']) {
                    horizontalInput -= 1;
                }
                
                // Check all possible right inputs  
                if (keys['d'] || keys['arrowright']) {
                    horizontalInput += 1;
                }
                
                // Apply horizontal movement
                if (horizontalInput !== 0) {
                    player.vx = horizontalInput * moveSpeed;
                    player.facing = horizontalInput;
                } else {
                    player.vx *= friction;
                }
                
                // Apply gravity and physics
                if (!player.grounded && !player.onWall) {
                    player.vy += gravity;
                } else if (player.onWall && player.vy > 0) {
                    player.vy *= 0.5; // Wall slide
                }
            } else {
                // IMPROVED: Allow some control during dash, but don't override dash momentum
                let horizontalInput = 0;
                
                if (keys['a'] || keys['arrowleft']) {
                    horizontalInput -= 1;
                }
                
                if (keys['d'] || keys['arrowright']) {
                    horizontalInput += 1;
                }
                
                // Allow minor course correction during dash
                if (horizontalInput !== 0) {
                    player.vx += horizontalInput * moveSpeed * 0.3; // 30% control during dash
                    player.facing = horizontalInput;
                }
                
                // Still apply gravity during dash
                if (!player.grounded && !player.onWall) {
                    player.vy += gravity;
                }
            }
            
            // Update position with speed modifier
            player.x += player.vx * gameSpeed;
            player.y += player.vy * gameSpeed;
            
            // Screen boundaries
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.size) player.x = canvas.width - player.size;
            
            if (player.y > canvas.height) {
                resetLevel();
                return;
            }
            
            // Enhanced hazard collision with special abilities
            level.hazards.forEach(hazard => {
                if (player.x + player.size > hazard.x && 
                    player.x < hazard.x + hazard.width &&
                    player.y + player.size > hazard.y && 
                    player.y < hazard.y + hazard.height) {
                    
                    let canSurvive = false;
                    
                    switch(hazard.type || 'deadly') {
                        case 'fire':
                            if (player.state === 'dashing') canSurvive = true;
                            break;
                        case 'electric':
                            if (player.state === 'just_teleported') canSurvive = true;
                            break;
                        case 'ice':
                            if (player.state === 'just_bounced') canSurvive = true;
                            break;
                        default:
                            canSurvive = false;
                            break;
                    }
                    
                    if (!canSurvive) {
                        resetLevel();
                        return;
                    }
                }
            });
            
            // Vibe collection - improved detection range
            level.vibes.forEach(vibe => {
                if (!vibe.collected) {
                    const dx = player.x + player.size/2 - vibe.x; // Center to center
                    const dy = player.y + player.size/2 - vibe.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // IMPROVED: Much larger collection radius - more forgiving
                    if (distance < player.size + vibe.size + 10) {
                        collectVibe(vibe);
                    }
                }
                vibe.pulse += 0.15 * gameSpeed;
            });
            
            // Goal collision with EPIC VORTEX EFFECT!
            const goal = level.goal;
            if (player.x + player.size > goal.x && 
                player.x < goal.x + goal.width &&
                player.y + player.size > goal.y && 
                player.y < goal.y + goal.height) {
                
                if (!goalEffect.active) {
                    // ACTIVATE THE VORTEX!
                    goalEffect.active = true;
                    goalEffect.time = 0;
                    goalEffect.centerX = goal.x + goal.width/2;
                    goalEffect.centerY = goal.y + goal.height/2;
                    
                    // Create initial explosion of particles
                    for (let i = 0; i < 50; i++) {
                        particles.push({
                            x: player.x + player.size/2, 
                            y: player.y + player.size/2,
                            vx: (Math.random() - 0.5) * 25,
                            vy: (Math.random() - 0.5) * 25,
                            life: 80, 
                            color: '#ffff00',
                            size: Math.random() * 12 + 4
                        });
                    }
                    
                    // Create vortex spiral particles
                    for (let i = 0; i < 100; i++) {
                        const angle = (i / 100) * Math.PI * 4; // Multiple spirals
                        const distance = 200 + Math.random() * 300;
                        goalEffect.vortexParticles.push({
                            angle: angle,
                            distance: distance,
                            speed: 0.1 + Math.random() * 0.05,
                            life: 100,
                            color: ['#ffff00', '#ff00ff', '#00ffff', '#00ff00'][Math.floor(Math.random() * 4)],
                            size: Math.random() * 6 + 2,
                            spiralSpeed: 2 + Math.random() * 3
                        });
                    }
                    
                    console.log("🌀 VORTEX ACTIVATED! REALITY IS BENDING!");
                }
                
                // Continue vortex effect for 2 seconds, then advance level
                if (goalEffect.time > 120) { // 2 seconds at 60fps
                    goalEffect.active = false;
                    goalEffect.vortexParticles = [];
                    nextLevel();
                }
                return;
            }
            
            player.animFrame += 0.2 * gameSpeed;
        }
        
        function update() {
            time += 0.02 * gameSpeed;
            updatePlayer();
            
            // Update regular particles
            particles = particles.filter(p => {
                p.x += p.vx * gameSpeed;
                p.y += p.vy * gameSpeed;
                p.life -= gameSpeed;
                p.vx *= 0.95;
                p.vy *= 0.95;
                return p.life > 0;
            });
            
            // Update EPIC VORTEX EFFECT
            if (goalEffect.active) {
                goalEffect.time += gameSpeed;
                
                // Update vortex particles - spiral toward center
                goalEffect.vortexParticles = goalEffect.vortexParticles.filter(p => {
                    // Spiral inward
                    p.angle += p.spiralSpeed * 0.02 * gameSpeed;
                    p.distance -= p.speed * 20 * gameSpeed;
                    p.life -= gameSpeed;
                    
                    // Add some chaos particles when they get close to center
                    if (p.distance < 50 && Math.random() < 0.3) {
                        particles.push({
                            x: goalEffect.centerX + Math.cos(p.angle) * p.distance,
                            y: goalEffect.centerY + Math.sin(p.angle) * p.distance,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 30,
                            color: p.color,
                            size: p.size * 0.5
                        });
                    }
                    
                    return p.life > 0 && p.distance > 5;
                });
                
                // Add more spiral particles during the effect
                if (goalEffect.time % 3 === 0) {
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 400 + Math.random() * 200;
                        goalEffect.vortexParticles.push({
                            angle: angle,
                            distance: distance,
                            speed: 0.15 + Math.random() * 0.1,
                            life: 80,
                            color: ['#ffff00', '#ff00ff', '#00ffff', '#00ff00', '#ffffff'][Math.floor(Math.random() * 5)],
                            size: Math.random() * 8 + 3,
                            spiralSpeed: 3 + Math.random() * 4
                        });
                    }
                }
            }
        }
        
        function render() {
            const level = getCurrentLevel();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Enhanced background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, level.bgColor || '#1a1a2e');
            gradient.addColorStop(1, '#0f0f23');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Subtle grid pattern
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            for (let x = 0; x < canvas.width; x += 32) {
                for (let y = 0; y < canvas.height; y += 32) {
                    if ((x + y) % 64 === 0) {
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
            
            // Enhanced platforms
            level.platforms.forEach(platform => {
                ctx.fillStyle = '#222';
                ctx.fillRect(platform.x + 2, platform.y + 2, platform.width, platform.height);
                
                ctx.fillStyle = '#555';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                ctx.fillStyle = '#777';
                ctx.fillRect(platform.x, platform.y, platform.width, 4);
                
                ctx.fillStyle = '#333';
                ctx.fillRect(platform.x, platform.y + platform.height - 2, platform.width, 2);
            });
            
            // Enhanced hazards with different types
            level.hazards.forEach(hazard => {
                const pulse = Math.sin(time * 8) * 0.1 + 0.9;
                
                switch(hazard.type || 'deadly') {
                    case 'fire':
                        ctx.fillStyle = `rgba(255, 100, 0, ${pulse})`;
                        ctx.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                        
                        ctx.fillStyle = '#ff6600';
                        for (let x = hazard.x; x < hazard.x + hazard.width; x += 12) {
                            for (let y = hazard.y; y < hazard.y + hazard.height; y += 8) {
                                if (Math.random() > 0.7) {
                                    ctx.fillRect(x + Math.random() * 4, y + Math.random() * 4, 2, 4);
                                }
                            }
                        }
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '16px Press Start 2P';
                        ctx.textAlign = 'center';
                        ctx.fillText('🔥', hazard.x + hazard.width/2, hazard.y + hazard.height/2 + 6);
                        break;
                        
                    case 'electric':
                        ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
                        ctx.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                        
                        ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            const x1 = hazard.x + Math.random() * hazard.width;
                            const y1 = hazard.y + Math.random() * hazard.height;
                            const x2 = hazard.x + Math.random() * hazard.width;
                            const y2 = hazard.y + Math.random() * hazard.height;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                        
                        ctx.fillStyle = '#000000';
                        ctx.font = '16px Press Start 2P';
                        ctx.textAlign = 'center';
                        ctx.fillText('⚡', hazard.x + hazard.width/2, hazard.y + hazard.height/2 + 6);
                        break;
                        
                    case 'ice':
                        ctx.fillStyle = `rgba(0, 255, 255, ${pulse * 0.7})`;
                        ctx.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                        
                        ctx.fillStyle = '#00ccff';
                        for (let x = hazard.x; x < hazard.x + hazard.width; x += 16) {
                            for (let y = hazard.y; y < hazard.y + hazard.height; y += 16) {
                                ctx.fillRect(x, y, 8, 2);
                                ctx.fillRect(x, y, 2, 8);
                            }
                        }
                        
                        ctx.fillStyle = '#003366';
                        ctx.font = '16px Press Start 2P';
                        ctx.textAlign = 'center';
                        ctx.fillText('❄', hazard.x + hazard.width/2, hazard.y + hazard.height/2 + 6);
                        break;
                        
                    default:
                        ctx.fillStyle = `rgba(255, 68, 68, ${pulse})`;
                        ctx.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                        
                        ctx.fillStyle = '#ff0000';
                        for (let x = hazard.x; x < hazard.x + hazard.width; x += 16) {
                            for (let y = hazard.y; y < hazard.y + hazard.height; y += 16) {
                                if ((x + y) % 32 === 0) {
                                    ctx.fillRect(x, y, 2, 2);
                                }
                            }
                        }
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '16px Press Start 2P';
                        ctx.textAlign = 'center';
                        ctx.fillText('💀', hazard.x + hazard.width/2, hazard.y + hazard.height/2 + 6);
                        break;
                }
            });
            
            // Grid lines with MUCH better visibility and auto-dash
            level.grids.forEach(grid => {
                // Check if player is in dash range for this grid
                let inRange = false;
                let distance = Infinity;
                
                if (grid.type === 'horizontal') {
                    distance = Math.abs(player.y - grid.y);
                    if (distance < 80 && 
                        player.x >= grid.start - 80 && 
                        player.x <= grid.end + 80) {
                        inRange = true;
                    }
                } else if (grid.type === 'vertical') {
                    distance = Math.abs(player.x - grid.x);
                    if (distance < 80 && 
                        player.y >= grid.start - 80 && 
                        player.y <= grid.end + 80) {
                        inRange = true;
                    }
                }
                
                // MASSIVE visual enhancement when in range
                if (inRange && actions.dashes > 0) {
                    // Huge bright pulsing line
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 8;
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 30;
                    
                    // Super obvious pulsing
                    const pulse = Math.sin(time * 15) * 0.5 + 0.5;
                    ctx.globalAlpha = 0.7 + pulse * 0.3;
                    
                    // Draw thick glowing line
                    ctx.beginPath();
                    if (grid.type === 'horizontal') {
                        ctx.moveTo(grid.start - 20, grid.y);
                        ctx.lineTo(grid.end + 20, grid.y);
                    } else {
                        ctx.moveTo(grid.x, grid.start - 20);
                        ctx.lineTo(grid.x, grid.end + 20);
                    }
                    ctx.stroke();
                    
                    // Add glowing particles along the line
                    if (Math.random() < 0.3) {
                        let particleX, particleY;
                        if (grid.type === 'horizontal') {
                            particleX = grid.start + Math.random() * (grid.end - grid.start);
                            particleY = grid.y;
                        } else {
                            particleX = grid.x;
                            particleY = grid.start + Math.random() * (grid.end - grid.start);
                        }
                        
                        particles.push({
                            x: particleX, y: particleY,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 20,
                            color: '#ffff00',
                            size: 3
                        });
                    }
                    
                    // HUGE text instruction
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Press Start 2P';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#000000';
                    ctx.shadowBlur = 5;
                    
                    let instructionText = '';
                    let instructionX, instructionY;
                    
                    if (grid.type === 'horizontal') {
                        instructionText = 'PRESS SHIFT TO DASH!';
                        instructionX = grid.start + (grid.end - grid.start)/2;
                        instructionY = grid.y - 40;
                    } else {
                        instructionText = 'PRESS SHIFT TO DASH!';
                        instructionX = grid.x + 60;
                        instructionY = grid.start + (grid.end - grid.start)/2;
                    }
                    
                    ctx.fillText(instructionText, instructionX, instructionY);
                    
                    // SPECIAL: Show combo hint for dash+jump levels
                    if (currentLevel === 3) {
                        ctx.fillStyle = '#00ff00';
                        ctx.font = '8px Press Start 2P';
                        ctx.fillText('THEN PRESS SPACE TO JUMP!', instructionX, instructionY + 20);
                    }
                    
                } else {
                    // Normal grid appearance
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.globalAlpha = 1;
                    
                    ctx.beginPath();
                    if (grid.type === 'horizontal') {
                        ctx.moveTo(grid.start, grid.y);
                        ctx.lineTo(grid.end, grid.y);
                    } else {
                        ctx.moveTo(grid.x, grid.start);
                        ctx.lineTo(grid.x, grid.end);
                    }
                    ctx.stroke();
                }
            });
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Enhanced trees with teleport range indicator
            level.trees.forEach(tree => {
                // Check if player is in teleport range
                const dx = player.x + player.size/2 - tree.x;
                const dy = player.y + player.size/2 - tree.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const inRange = distance < tree.size + 40;
                
                // Show range indicator when close
                if (inRange && actions.teleports > 0) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(tree.x, tree.y - tree.size * 0.3, tree.size + 40, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Tree trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(tree.x - 4, tree.y, 8, tree.size);
                
                // Tree crown with enhanced glow when in range
                ctx.fillStyle = '#00ff00';
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = inRange && actions.teleports > 0 ? 25 : 15;
                ctx.beginPath();
                ctx.arc(tree.x, tree.y - tree.size * 0.3, tree.size * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Tree details
                ctx.fillStyle = '#00cc00';
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const px = tree.x + Math.cos(angle) * tree.size * 0.5;
                    const py = tree.y - tree.size * 0.3 + Math.sin(angle) * tree.size * 0.5;
                    ctx.fillRect(px, py, 2, 2);
                }
                
                // Show teleport hint when in range
                if (inRange && actions.teleports > 0) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '8px Press Start 2P';
                    ctx.textAlign = 'center';
                    ctx.fillText('PRESS E', tree.x, tree.y - tree.size - 10);
                }
            });
            
            // Enhanced walls with wall bounce indicators
            level.walls.forEach(wall => {
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8;
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#00cccc';
                for (let y = wall.y; y < wall.y + wall.height; y += 8) {
                    ctx.fillRect(wall.x, y, wall.width, 2);
                }
                
                // Show wall bounce hint when touching wall
                if (player.onWall && actions.wallbounces > 0) {
                    const isThisWall = (player.wallSide === 'left' && Math.abs(player.x + player.size - wall.x) < 15) ||
                                     (player.wallSide === 'right' && Math.abs(player.x - (wall.x + wall.width)) < 15);
                    
                    if (isThisWall && 
                        player.y + player.size > wall.y && 
                        player.y < wall.y + wall.height) {
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '8px Press Start 2P';
                        ctx.textAlign = 'center';
                        
                        const hintX = wall.x + wall.width/2;
                        const hintY = player.y - 10;
                        
                        ctx.fillText('PRESS SPACE', hintX, hintY);
                        
                        // Visual bounce indicator
                        ctx.fillStyle = '#ffff00';
                        ctx.shadowColor = '#ffff00';
                        ctx.shadowBlur = 10;
                        const bounceDirection = player.wallSide === 'left' ? 1 : -1;
                        const arrowX = player.x + (bounceDirection * 20);
                        const arrowY = player.y;
                        
                        // Draw bounce arrow
                        ctx.fillText('↗', arrowX, arrowY);
                        ctx.shadowBlur = 0;
                    }
                }
            });
            
            // Vibes
            const vibeColors = {
                jump: '#ffffff',
                dash: '#ff00ff',
                teleport: '#00ff00', 
                wallbounce: '#00ffff'
            };
            
            level.vibes.forEach(vibe => {
                if (!vibe.collected) {
                    const pulseSize = vibe.size + Math.sin(vibe.pulse) * 4;
                    const glowIntensity = Math.sin(vibe.pulse * 2) * 0.3 + 0.7;
                    
                    ctx.fillStyle = vibeColors[vibe.type];
                    ctx.shadowColor = vibeColors[vibe.type];
                    ctx.shadowBlur = 20 * glowIntensity;
                    ctx.beginPath();
                    ctx.arc(vibe.x, vibe.y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = '#000';
                    ctx.font = '12px Press Start 2P';
                    ctx.textAlign = 'center';
                    const symbols = { jump: '↑', dash: '→', teleport: '⚡', wallbounce: '↗' };
                    ctx.fillText(symbols[vibe.type], vibe.x, vibe.y + 4);
                    
                    for (let i = 0; i < 3; i++) {
                        const angle = vibe.pulse + (i * Math.PI * 2 / 3);
                        const orbit = pulseSize + 10;
                        const px = vibe.x + Math.cos(angle) * orbit;
                        const py = vibe.y + Math.sin(angle) * orbit;
                        
                        ctx.fillStyle = vibeColors[vibe.type];
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(px - 1, py - 1, 2, 2);
                        ctx.globalAlpha = 1;
                    }
                }
            });
            
            // Enhanced goal with EPIC VORTEX EFFECTS
            const goal = level.goal;
            
            if (goalEffect.active) {
                // VORTEX BACKGROUND DISTORTION
                const vortexIntensity = Math.min(goalEffect.time / 60, 1); // Fade in over 1 second
                
                // Dark vortex background
                const gradient = ctx.createRadialGradient(
                    goalEffect.centerX, goalEffect.centerY, 0,
                    goalEffect.centerX, goalEffect.centerY, 300 * vortexIntensity
                );
                gradient.addColorStop(0, `rgba(0, 0, 0, ${0.8 * vortexIntensity})`);
                gradient.addColorStop(0.3, `rgba(50, 0, 50, ${0.6 * vortexIntensity})`);
                gradient.addColorStop(0.7, `rgba(100, 0, 100, ${0.3 * vortexIntensity})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // SPINNING VORTEX RINGS
                ctx.strokeStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
                for (let ring = 0; ring < 8; ring++) {
                    const radius = 20 + ring * 30;
                    const rotation = goalEffect.time * 0.05 * (ring % 2 === 0 ? 1 : -1);
                    
                    ctx.globalAlpha = (1 - ring / 8) * vortexIntensity;
                    ctx.lineWidth = 3 - ring * 0.3;
                    
                    ctx.beginPath();
                    for (let i = 0; i < 360; i += 10) {
                        const angle = (i * Math.PI / 180) + rotation;
                        const waveRadius = radius + Math.sin(angle * 4 + goalEffect.time * 0.1) * 5;
                        const x = goalEffect.centerX + Math.cos(angle) * waveRadius;
                        const y = goalEffect.centerY + Math.sin(angle) * waveRadius;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                
                // VORTEX SPIRAL PARTICLES
                goalEffect.vortexParticles.forEach(p => {
                    const x = goalEffect.centerX + Math.cos(p.angle) * p.distance;
                    const y = goalEffect.centerY + Math.sin(p.angle) * p.distance;
                    
                    // Particle trail effect
                    const trailLength = 5;
                    for (let t = 0; t < trailLength; t++) {
                        const trailAngle = p.angle - (t * 0.1);
                        const trailDist = p.distance + (t * 10);
                        const trailX = goalEffect.centerX + Math.cos(trailAngle) * trailDist;
                        const trailY = goalEffect.centerY + Math.sin(trailAngle) * trailDist;
                        
                        ctx.globalAlpha = (1 - t / trailLength) * (p.life / 100);
                        ctx.fillStyle = p.color;
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 10;
                        ctx.fillRect(trailX - (p.size * (1 - t/trailLength))/2, 
                                   trailY - (p.size * (1 - t/trailLength))/2, 
                                   p.size * (1 - t/trailLength), 
                                   p.size * (1 - t/trailLength));
                    }
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                });
                
                // CENTRAL BLACK HOLE
                const blackHoleRadius = 15 + Math.sin(goalEffect.time * 0.1) * 5;
                const blackHoleGradient = ctx.createRadialGradient(
                    goalEffect.centerX, goalEffect.centerY, 0,
                    goalEffect.centerX, goalEffect.centerY, blackHoleRadius
                );
                blackHoleGradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                blackHoleGradient.addColorStop(0.7, 'rgba(100, 0, 100, 0.8)');
                blackHoleGradient.addColorStop(1, 'rgba(255, 255, 0, 0.3)');
                
                ctx.fillStyle = blackHoleGradient;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(goalEffect.centerX, goalEffect.centerY, blackHoleRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // REALITY DISTORTION TEXT
                if (goalEffect.time > 30) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '12px Press Start 2P';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 15;
                    
                    const messages = [
                        'REALITY BENDING...',
                        'ENTERING VORTEX...',
                        'SPACE-TIME FOLDING...',
                        'DIMENSION SHIFT...'
                    ];
                    const messageIndex = Math.floor(goalEffect.time / 30) % messages.length;
                    
                    ctx.globalAlpha = Math.sin(goalEffect.time * 0.2) * 0.5 + 0.5;
                    ctx.fillText(messages[messageIndex], 
                               goalEffect.centerX, 
                               goalEffect.centerY - 60);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            } else {
                // Normal goal (castle) when no vortex
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 15;
                ctx.fillRect(goal.x, goal.y, goal.width, goal.height);
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(goal.x, goal.y, goal.width, 8);
                ctx.fillRect(goal.x, goal.y + goal.height - 8, goal.width, 8);
                
                ctx.fillStyle = '#000';
                ctx.fillRect(goal.x + 8, goal.y + 12, 6, 8);
                ctx.fillRect(goal.x + goal.width - 14, goal.y + 12, 6, 8);
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(goal.x + goal.width/2 - 8, goal.y - 12, 16, 8);
                ctx.fillStyle = '#000';
                ctx.fillRect(goal.x + goal.width/2 - 1, goal.y - 4, 2, 12);
            }
            
            // Enhanced player with better visual feedback
            ctx.save();
            ctx.translate(player.x + player.size/2, player.y + player.size/2);
            ctx.scale(player.facing, 1);
            
            // Show if player can jump (grounded or coyote time)
            const now = Date.now();
            const recentlyDashed = (now - lastDashTime) < 200;
            const canJump = player.grounded || recentlyDashed;
            
            // Player glow effect - different colors based on state
            let glowColor = '#ffffff';
            if (player.state === 'dashing') glowColor = '#ff00ff';
            else if (recentlyDashed && !player.grounded) glowColor = '#ffff00'; // Yellow if can coyote jump
            else if (player.grounded) glowColor = '#00ff00'; // Green if grounded
            
            ctx.fillStyle = glowColor;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = canJump ? 12 : 8;
            ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
            ctx.shadowBlur = 0;
            
            // Player state colors
            let playerColor = '#4444ff';
            if (player.state === 'dashing') playerColor = '#ff00ff';
            else if (player.state === 'just_teleported') playerColor = '#00ff00';
            else if (player.state === 'just_bounced') playerColor = '#00ffff';
            
            ctx.fillStyle = playerColor;
            ctx.fillRect(-6, -6, 12, 12);
            
            ctx.fillStyle = '#000';
            ctx.fillRect(-2, -4, 1, 1);
            ctx.fillRect(1, -4, 1, 1);
            
            if (player.state === 'dashing') {
                ctx.fillStyle = '#ff00ff';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(-8 - i * 3, -2, 2, 4);
                }
            }
            
            // Show jump availability
            if (canJump && actions.jumps > 0) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '8px Press Start 2P';
                ctx.textAlign = 'center';
                ctx.fillText('SPACE', 0, -15);
            }
            
            ctx.restore();
            
            // Particles
            particles.forEach(p => {
                const alpha = p.life / 50;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                
                if (p.size) {
                    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                } else {
                    ctx.fillRect(p.x, p.y, 2, 2);
                }
            });
            ctx.globalAlpha = 1;
            
            ctx.restore(); // Restore after screen shake
        }
        
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize game and speed control
        function initializeGame() {
            // Setup speed control
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            
            if (speedSlider && speedValue) {
                speedSlider.addEventListener('input', (e) => {
                    gameSpeed = parseFloat(e.target.value);
                    speedValue.textContent = gameSpeed.toFixed(1);
                });
            }
            
            // Load first level and start game
            loadLevel(1);
            updateUI();
            gameLoop();
            
            console.log("🎮 Art Crash initialized!");
            console.log("🎯 Speed control: 0.3x (slow) to 2.0x (fast)");
            console.log("🎯 Multi-key support: Hold A+SPACE, SHIFT+D, etc.");
            console.log("🔧 Debug: N/P to skip levels");
        }
        
        // Start when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
    </script>
</body>
</html>
